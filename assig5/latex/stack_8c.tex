\section{stack.c File Reference}
\label{stack_8c}\index{stack.c@{stack.c}}
{\tt \#include $<$stdlib.h$>$}\par
{\tt \#include \char`\"{}stack.h\char`\"{}}\par
\subsection*{Functions}
\begin{CompactItemize}
\item 
\bf{Stack} $\ast$ \bf{create\_\-stack} (int max\_\-cells)
\item 
void \bf{delete\_\-stack} (\bf{Stack} $\ast$which\_\-stack)
\item 
int \bf{push} (\bf{Stack} $\ast$which\_\-stack, void $\ast$ptr)
\item 
void $\ast$ \bf{pop} (\bf{Stack} $\ast$which\_\-stack)
\item 
void $\ast$ \bf{peek} (\bf{Stack} $\ast$which\_\-stack)
\end{CompactItemize}


\subsection{Function Documentation}
\index{stack.c@{stack.c}!create_stack@{create\_\-stack}}
\index{create_stack@{create\_\-stack}!stack.c@{stack.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}\bf{Stack}$\ast$ create\_\-stack (int {\em max\_\-cells})}\label{stack_8c_95307d53d00d64c88d94459933faab55}


Create a stack by allocating a Stack structure, initializing it, and allocating memory to hold the stack entries. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em max\_\-cells}]Maximum entries in the stack \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Pointer to newly-allocated Stack structure, NULL if error. \end{Desc}
\index{stack.c@{stack.c}!delete_stack@{delete\_\-stack}}
\index{delete_stack@{delete\_\-stack}!stack.c@{stack.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void delete\_\-stack (\bf{Stack} $\ast$ {\em which\_\-stack})}\label{stack_8c_51a8e7dcd59c4eeacab0a6fcbd9779f0}


Deletes a stack, including the structure and the memory for holding the stack entries, but not the entries themselves. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em which\_\-stack}]Pointer to Stack structure. \end{description}
\end{Desc}
\index{stack.c@{stack.c}!peek@{peek}}
\index{peek@{peek}!stack.c@{stack.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ peek (\bf{Stack} $\ast$ {\em which\_\-stack})}\label{stack_8c_75f168a88a2f0eb5054b9eb571b3dd77}


Peek at top of stack, without popping \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em which\_\-stack}]Pointer to Stack you want to peek into \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Top entry of the stack, NULL if stack is empty. \end{Desc}
\index{stack.c@{stack.c}!pop@{pop}}
\index{pop@{pop}!stack.c@{stack.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ pop (\bf{Stack} $\ast$ {\em which\_\-stack})}\label{stack_8c_d02fd402bed8958596a341fbef57f0a7}


Pops top of stack, and returns it. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em which\_\-stack}]Pointer to Stack you want to pop from. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Top entry of the stack, NULL if stack is empty. \end{Desc}
\index{stack.c@{stack.c}!push@{push}}
\index{push@{push}!stack.c@{stack.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int push (\bf{Stack} $\ast$ {\em which\_\-stack}, void $\ast$ {\em ptr})}\label{stack_8c_006917f7e90d844cb8b0f14beee2d699}


Pushes a pointer onto a Stack. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em which\_\-stack}]Pointer to stack you want to push onto. \item[{\em ptr}]Pointer to be pushed. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]0 if successful, -1 if not. \end{Desc}
