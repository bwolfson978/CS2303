\section{stack.h File Reference}
\label{stack_8h}\index{stack.h@{stack.h}}
\subsection*{Classes}
\begin{CompactItemize}
\item 
struct \bf{stack}
\end{CompactItemize}
\subsection*{Typedefs}
\begin{CompactItemize}
\item 
typedef \bf{stack} \bf{Stack}
\end{CompactItemize}
\subsection*{Functions}
\begin{CompactItemize}
\item 
\bf{Stack} $\ast$ \bf{create\_\-stack} (int max\_\-cells)
\item 
void \bf{delete\_\-stack} (\bf{Stack} $\ast$which\_\-stack)
\item 
int \bf{push} (\bf{Stack} $\ast$which\_\-stack, void $\ast$ptr)
\item 
void $\ast$ \bf{pop} (\bf{Stack} $\ast$which\_\-stack)
\item 
void $\ast$ \bf{peek} (\bf{Stack} $\ast$which\_\-stack)
\end{CompactItemize}


\subsection{Typedef Documentation}
\index{stack.h@{stack.h}!Stack@{Stack}}
\index{Stack@{Stack}!stack.h@{stack.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}typedef struct \bf{stack} \bf{Stack}}\label{stack_8h_a7883e8bf747b9dedec990b539df2cc0}




\subsection{Function Documentation}
\index{stack.h@{stack.h}!create_stack@{create\_\-stack}}
\index{create_stack@{create\_\-stack}!stack.h@{stack.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}\bf{Stack}$\ast$ create\_\-stack (int {\em max\_\-cells})}\label{stack_8h_95307d53d00d64c88d94459933faab55}


Create a stack by allocating a Stack structure, initializing it, and allocating memory to hold the stack entries. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em max\_\-cells}]Maximum entries in the stack \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Pointer to newly-allocated Stack structure, NULL if error. \end{Desc}
\index{stack.h@{stack.h}!delete_stack@{delete\_\-stack}}
\index{delete_stack@{delete\_\-stack}!stack.h@{stack.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void delete\_\-stack (\bf{Stack} $\ast$ {\em which\_\-stack})}\label{stack_8h_51a8e7dcd59c4eeacab0a6fcbd9779f0}


Deletes a stack, including the structure and the memory for holding the stack entries, but not the entries themselves. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em which\_\-stack}]Pointer to Stack structure. \end{description}
\end{Desc}
\index{stack.h@{stack.h}!peek@{peek}}
\index{peek@{peek}!stack.h@{stack.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ peek (\bf{Stack} $\ast$ {\em which\_\-stack})}\label{stack_8h_75f168a88a2f0eb5054b9eb571b3dd77}


Peek at top of stack, without popping \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em which\_\-stack}]Pointer to Stack you want to peek into \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Top entry of the stack, NULL if stack is empty. \end{Desc}
\index{stack.h@{stack.h}!pop@{pop}}
\index{pop@{pop}!stack.h@{stack.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ pop (\bf{Stack} $\ast$ {\em which\_\-stack})}\label{stack_8h_d02fd402bed8958596a341fbef57f0a7}


Pops top of stack, and returns it. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em which\_\-stack}]Pointer to Stack you want to pop from. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Top entry of the stack, NULL if stack is empty. \end{Desc}
\index{stack.h@{stack.h}!push@{push}}
\index{push@{push}!stack.h@{stack.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int push (\bf{Stack} $\ast$ {\em which\_\-stack}, void $\ast$ {\em ptr})}\label{stack_8h_006917f7e90d844cb8b0f14beee2d699}


Pushes a pointer onto a Stack. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em which\_\-stack}]Pointer to stack you want to push onto. \item[{\em ptr}]Pointer to be pushed. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]0 if successful, -1 if not. \end{Desc}
